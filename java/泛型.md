泛型：应用于许多许多的类型。
使代码能够应用于“某种不具体的类型”，而不是一个具体的接口或类。

Java SE5的重大变化之一：泛型的概念。

泛型实现了参数化类型的概念，使代码可以应用于多种类型。

# 简单泛型

有许多原因促成了泛型的出现，而最引入注目的一个原因，就是为了创建容器类。

泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。

*[Holder.java](src/FamilyVsExactType/src/com/tlxxm/learing/Holder.java)*

	package com.tlxxm.learing;
	
	class Man{}
	public class Holder<T> {
	    private T a;
	    public  Holder(T t){
	        a=t;
	    }
	    public void set(T t){
	        a=t;
	    }
	    public T get(){
	        return a;
	    }
	
	    public static void main(String[] args) {
		    Holder<Man> holder=new Holder(new Man());
		    Man man=holder.get();
	    }
	}


# 一个元组类库

仅一次方法调用就能返回多个对象，可是return语句只允许返回单个对象，因此解决办法就是创建一个  
对象，用它来持有想要返回的多个对象。

这个概念称为元组(tuple)，它是将一组对象直接打包存储于其中的一个单一对象。
这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。（这个概念也称为数据传递对象或信使。）

通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。
比如：

*[TwoTuple.java](src/TwoTuple/src/com/tlxxm/learing/TwoTuple.java)*

	package com.tlxxm.learing;
	
	public class TwoTuple<A,B> {
	    public final A first;
	    public final B second;
	    public TwoTuple(A a,B b){
	        first=a;
	        second=b;
	    }
	    public String toString(){
	        return "("+first+","+second+")";
	    }
	
	    public static void main(String[] args) {
		// write your code here
	    }
	}

可以通过继承，创建任意适合长度的元组。

为了使用元组，只需要定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建  
该元组，并返回即可。

final声明能够保护元组内的对象引用，不被改变。

# 泛型接口

# 泛型方法

可以在类中包含参数化方法，而这个方法所在的类可以是

