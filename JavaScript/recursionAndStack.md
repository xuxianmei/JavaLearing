## 递归与堆栈

## 递归
递归是一种编程模式，用于一个任务可以被分割为多个相似的更简单的任务的场景。
或者用于一个任务可以被简化为一个容易的行为加上更简单的任务变体。
或者像我们随后会看到的，用来处理特定类型的数据结构。

当一个函数解决一个任务时，在该过程中它可以调用很多其它函数。
那么当一个函数调用自身时，就称其为递归。

两种思考方式
---
简单起见，我们写一个函数 pow(x, n)，它可以计算 x 的 n 次方，即用 x 乘以自身 n 次。
```
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```
有两种实现方式。

迭代思路：for 循环：
```
 function pow(x, n) {
  let result = 1;

  // 在循环中用 x 乘以 result
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
```
递归思路：简化任务，调用自身：
```

 function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```
注意递归方式完全不相同。

当 pow(x, n) 被调用时，执行分为两个分支：
```
              if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
```
s
如果 n == 1，所有事情都会很简单，这叫做递归的基础，因为它立即得到显而易见的结果：pow(x, 1) 等于 x。
否则，我们可以用`` x * pow(x, n - 1) 表示 pow(x, n)``。
在数学里，可能会这么写`` xn = x * xn-1``。

这叫做一个递归步骤：我们将任务转变为更简单的行为（x 的乘法）和更简单的同类任务调用（更小的 n 给 pow）。
后面步骤继续简化直到 n 等于 1。
我们也可以说 pow 递归的调用自身 直到 n == 1。

比如，为了计算 pow(2, 4)，递归变体经过了下面几个步骤：
```
pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2
```
所以，递归生成了更简单的函数调用，然后 —— 更加简单，继续，直到结果变得很明显。

最大的嵌套调用次数（包括首次）称为递归深度。在我们的例子中，它正好等于 n。

最大递归深度受限于 JavaScript 引擎。我们可以确信基本是 10000，有些引擎可能允许更大，但是 100000 很可能就超过了限制。有一些自动优化能够缓解这个（「尾部调用优化」），但是它们还没有被完全支持，只能用于简单场景。

这就限制了递归的应用，但是递归仍然被广泛使用。有很多任务使用递归思路会让代码更简单，更容易维护。

## 执行堆栈

现在我们来研究下递归调用如何工作的。为此，我们会先看看函数底层工作原理。

一个函数运行的信息被存储在它的执行上下文里。

执行上下文是一个内部数据结构。
它包含一个函数执行时的细节：当前工作流在哪里，当前的变量，this 的值（这里我们不使用它），以及其它一些内部细节。

每个函数调用都有与其相关联的执行上下文。

当一个函数有嵌套调用时，下面的事情会发生：

* 当前函数被暂停；
* 与它关联的执行上下文被一个叫做执行上下文堆栈的特殊数据结构保存；
* 执行嵌套调用；
* 嵌套调用结束后，之前的执行上下文从堆栈中恢复，外部函数从停止的地方继续执行。

我们看看调用 pow(2, 3) 都发生了什么。
在调用 pow(2, 3) 的开始，执行上下文会存储变量：x = 2, n = 3，执行流程在函数的第 1 行。

我们将其描绘如下：

pow(2, 3)
---

* | Context: { x: 2, n: 3, at line 1 } | call:pow(2, 3) 

这是函数开始执行的时候。条件 n == 1 结果为否，所以流程进入 if 的第二分支。
```
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
```
变量相同，但是函数变化了，所以现在上下文是：
* | Context: { x: 2, n: 3, at line 5 } | call:pow(2, 3)

为了计算 x * pow(x, n - 1)，我们需要用新的参数 pow(2, 2) 子调用 pow。

pow（2, 2)
---
为了执行嵌套调用，JavaScript 会记住执行上下文堆栈中的当前执行上下文。

这里我们调用相同的函数 pow，但是没关系。所有函数的处理都是一样的：

* 当前上下文被「记录」在堆栈的顶部；
* 为子调用创建新上下文；
* 当子调用结束后 —— 前一上下文从堆栈弹出，继续执行。

下面是进入子调用 pow(2, 2) 的上下文堆栈：

* **| Context: { x: 2, n: 2, at line 1 } | call: pow(2, 2)**
* | Context: { x: 2, n: 3, at line 5 } | call:pow(2, 3)

新的当前执行上下文位于顶部（加粗），前面的在下方。

当我们完成子调用后 ——很容恢复前面的上下文，因为它保留这变量和代码停止时的准确位置。我们使用了单词「line」，但实际比这更精确。

pow(2, 1)
重复该过程：在第 5 行生成新的子调用，现在使用参数 x=2，n=1。

新的执行上下文被创建，前一个被压入堆栈顶部：

- **| Context: { x: 2, n: 1, at line 1 } | call: pow(2, 1)**
* | Context: { x: 2, n: 2, at line 5 } | call: pow(2, 2)
* | Context: { x: 2, n: 3, at line 5 } | call:pow(2, 3)

此时，有 2 个旧的上下文和 1 个当前正在运行的给 pow(2, 1) 的上下文。

出口
---
在 pow(2, 1) 时，不像之前，条件 n == 1 成了是，所以 if 的第一分支生效：
```
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```
此时不再有嵌套调用，所以函数结束，返回 2。

函数结束后，它的执行上下文不再有用，会从内存中移除。前一上下文从栈顶恢复：

恢复执行 pow(2, 2)，它有子调用 pow(2, 1) 的结果，所以它也可以结束 x * pow(x, n - 1) 的执行，返回 4。

然后前一上下文被恢复：
Context: { x: 2, n: 3, at line 5 } call: pow(2, 3)

当它结束后，我们得到结果 pow(2, 3) = 8。

递归深度是：3。

从上面的图解可以看到，递归深度等于堆栈中上下文的最大个数。

注意内存要求。上下文消耗内存，在我们的例子中，求 n 次方需要存储 n 个上下文，以便减一后的 n 使用。

而循环算法更省内存：
```
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```
迭代 pow 仅使用一个上下文，在处理中修改 i 和 result。它的内存要求比较小，且固定不依赖 n。

任何递归都可以用循环来重写。循环变体一般更加有效。
但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂。而且有些优化可能没有必要，完全不值得。

递归能提供更简洁的代码，容易理解和维护。优化并不是处处需要，大多数时候我们需要一个好代码，这就是它被使用的原因。

[可视化执行过程](http://www.pythontutor.com/visualize.html#code=function%20pow%28x,%20n%29%20%7B%0A%20%20if%20%28n%20%3D%3D%201%29%20%7B%0A%20%20%20%20return%20x%3B%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20x%20*%20pow%28x,%20n%20-%201%29%3B%0A%20%20%7D%0A%7D%0A%0Alet%20t%3Dpow%282,%203%29%3B%0A&cumulative=false&curInstr=7&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=js&rawInputLstJSON=%5B%5D&textReferences=false)
