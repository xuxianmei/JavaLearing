# 对象

## 抽象机制

人们所能够解决的问题的复杂性，直接取决于抽象的**类型**（指的是针对什么进行抽象）和 **质量**

程序员必须在*机器模型（位于解空间，这是对问题建模的地方*和*实际待解的模型（位于问题空间内，这是问题存在的地方）*之间建立关联。


#### 面向对象

面向对象思想实质
> 程序可以通过添加新类型的对象（问题空间中的元素及其在解空间中的表示称为**对象**）使自身适用于某个特定问题。  
因此，当你在阅读描述解决方案的代码的同时，也是在阅读问题的描述。

* 面向对象语言的基本特性
  1. 万物皆对象    
	 >将对象视为特殊的变量，可以存储数据和自带的行为操作。
  2. 程序是对象的集合，它们通过发送消息 来告知彼此所要做的  
     >要想请求一个对象，就必须对该对象发送一条消息，可以把消息想像为对某个特定对象的方法的调用请求。
  3. 每个对象都有由其他对象所构成的存储  
     > 可以通过创建包含现有对象的包的方式来创建新类型的对象。因为，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。
  4. 每个对象都拥有其类型    
      >每个对象都是某个类的一个实例。
  5. 某一特定类型的所有对象都可以接收同样的消息
     >同属一个大类型的对象，都有同样的消息接口，但消息内部执行的操作由具体的类型自己实现。这种可替代性是OOP中最强有力的概念之一。

 * 更加简洁的描述

   > 对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据和方法，并且在内在中都有一个唯一的地址。


---
* 类

> 因为类描述了具有相同特性和行为的对象集合。
类实际上就是一个数据类型。例如所有整数弄数据具有相同的特性和行为集合。 
**创建类（现实问题到机器当中的抽象数据类型）是面向对象程序设计的基本概念之一**。  
每一个对象都属于定义了特性和行为的某个特定的类。  

  面向对象程序设计的挑战之一，就是**在问题空间的元素和解空间的对象之间创建一对一的映射**。
* 对象
通过对象概念，将数据和功能封装到一起，可以对问题空间的观念给出恰当的表示，而不用受制于必须使用底层机器语言。
	* 每个对象都有一个接口
	>必须有某种方式产生对对象的请求，使对象完成各种任务，才能获得真正有用的对象。
	>每个对象都只能满足某些请求，这些请求由**对象的接口**所定义。

	* 每个对象都提供服务
	>程序本身通过**调用其他对象提供的服务**来实现**向用户提供服务**。

	程序设计的目的就是去**_创建能够提供理想的服务来解决问题的一系列对象_**。

	在面向对象当中，**_将对象看作真正的服务提供者_**。
---
* 被隐藏的具体实现

	通过隐藏现实
	类使用者不用关心内部实现，可以任意使用类开放出来的功能。
	类创建者，可以任意修改内部的实现，而不影响使用者的使用。 

	访问控制存在原因
	1. 让类使用者无法触及他们不应该触及的部分，这对使用者来说接口其实是一项服务，不用关心服务的具体实现。
	2. 允许类创建者可以改变类内部的工作方式而不用担心会影响类使用者 
---
* 复用具体实现
代码利用是面向对象程序设计语言提供的最了不起的优点之一。
一旦类被创建并被测试完，就应该代表一个有用的代码单元。
复用类的方式
	1. 直接使用类的一个对象  
	新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能方式组成。
	2. 通过继承一个类
	不仅包括现有类型的所有成员（除private成员），且复制了基类的接口。
---
* 继承
	类型不仅仅只是描述了作用于一个对象集合上的约束条，同时还有与其他类型之间的关系。
两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多的特性，并且可以处理更多的消息（或者以不同的方式来处理消息）。  
继承使用了**_基类型_**和**_导出类型_**的概念表示了这种类型之间的相似性。  
通过继承现有类型，创建了新的类型，不仅包括现有类型的所有成员，且复制了基类的接口。
也就是说，所有可以发送给基类对象的消息同时，也可以发送给导出类对象。  
这也就意味着**_导出类和基类具有相同的类型_**。
通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。
有两种方法可以使基类与产生差异：
	1. 直接在导出类中添加新方法
	这些新方法并不是基类接口的一部分
	2. 改变现有基类的方法的行为
	通过覆盖基类方法的行为，产生差异
---
* is-a 与 is-like-a
	* is-a 
	继承时，只覆盖基类的方法，它们具有相同的接口，意味着导出类和基类是完全相同的类型，
    可以用一个导出类对象来完全替代一个基类对象（被视为纯粹替代）。
	* is-like-a 
	继承时，添加了新的接口元素来扩展了接口，这个新的类型仍然可以替代基类，但是因为基类无法访问新添加的方法，所以不是纯粹替代。
	