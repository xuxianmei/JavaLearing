通过创建新类来复用代码，不必再重头开始编写，此方法可以使用类而不破坏程序代码。

# 组合
只需将对象引用置于新类中即可。

*[SprinklerSystem.java](src/reuseClassAggregation/src/com/tlxxm/learing/SprinklerSystem.java)*  

	package com.tlxxm.learing;
	//复用类之聚合 SprinklerSystem 利用聚合，使用WaterSource类
	public class SprinklerSystem {
	    private String value1,value2,value3,value4;
	    private WaterSource source=new WaterSource();
	    private int i;
	    private float f;
	    @Override
	    public String toString(){
	        return
	                "value1 = "+value1+","+
	                "value2 = "+value2+","+
	                "value3 = "+value3+","+
	                "value4 = "+value4+"\n"+
	                "i = "+i+","+
	                "f = "+f+","+
	                "source = "+source;
	    }
	    public static void main(String[] args) {
	        SprinklerSystem sprinklerSystem=new SprinklerSystem();
	        System.out.println(sprinklerSystem);
	    }
	}
	class WaterSource{
	    private String s;
	    WaterSource(){
	        System.out.println("WaterSource()");
	        s="Constructed";
	    }
	    @Override
	    public String toString(){
	        return s;
	    }
	}


# 继承

除非已明确指出要从其他类中继承，否则就是隐式地从Java的标准根类Object进行继承。

在继承过程中，使用extends实现，当这么做时，会自动得到基类中所有的域和方法。

*[Detergent.java](src/reuseClassExtends/src/com/tlxxm/learing/Detergent.java)*

	package com.tlxxm.learing;	

	class Cleanser{
	    private String s="Cleanser";
	    public void append(String a){
	        s+=a;
	    }
	    public void dilute(){
	        append(" dilute()");
	    }
	    public void apply(){
	        append(" append");
	    }
	    public void scrub(){
	        append(" scrub()");
	    }
	    public String toString(){
	        return s;
	    }
	    public static void main(String[] args) {
	        Cleanser x=new Cleanser();
	        x.dilute();
	        x.apply();
	        x.scrub();
	        System.out.println(x);
	    }
	
	}
	public class Detergent extends Cleanser{
	    //重写了基类方法
	    public void scrub(){
	        append(" Detergent.scrub()");;
	        super.scrub();//super关键字表示超类
	    }
	    public void foam(){
	        append(" foam()");
	    }
	    public static void main(String[] args) {
	        Detergent x=new Detergent();
	        x.dilute();
	        x.apply();
	        x.scrub();
	        x.foam();
	        System.out.println(x);
	        System.out.println("Testing base class:");
	        Cleanser.main(args);
	    }
	}
  

##  基类的初始化
继承以后，子类就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。
但继承并不只是复制基类的接口。
当创建一个子类的对象时，该对象还包含了一个基类的子对象。
这个子对象与你用基类直接创建对象是一样的。

对基类子对象的正确初始化是至关重要的，只有一种方法来保证这一点：
在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需要  
的所有知识和能力。
* 默认构造器(无参构造器)
Java会自动在导出类的构造器中插入对基类构造器的调用。
*[Cartoon.java](src/baseClassInitilization/src/com/tlxxm/learing/Cartoon.java)*
		package com.tlxxm.learing;
		
		public class Cartoon extends Drawing {
		    Cartoon(){
		        System.out.println("Cartoon constructor");
		    }
		    public static void main(String[] args) {
			 Cartoon cartoon=new Cartoon();
		    }
		}
		class Art{
		    Art(){
		        System.out.println("Art constructor");
		    }
		}
		class Drawing extends Art{
		    Drawing(){
		        System.out.println("Drawing constructor");
		    }
		}

**Output：**
>Art constructor
>Drawing constructor
>Cartoon constructor


* 带参数的构造器
	如果没有默认的基类构造器（无参构造器），或者想调用一个带参数的基类构造器，就必须使用super显式调用，并且配以适当的参数列表。
	
	*[Chess.java](src/baseClassInitilization2/src/com/tlxxm/learing/Chess.java)*
	
		package com.tlxxm.learing;
		
		public class Chess extends BoardGame {
		
		    Chess(){
		        super(1);
		        System.out.println("Chess constructor");
		
		    }
		    public static void main(String[] args) {
			// write your code here
		        Chess chess=new Chess();
		    }
		}
		
		class Game{
		    Game(int i){
		        System.out.println("Game constructor");
		    }
		}
		class BoardGame extends Game{
		    BoardGame(int i)
		    {
		        super(i);
		        System.out.println("BoardGame constructor");
		    }
		}
**Output：**
>Game constructor
>BoardGame constructor
>Chess constructor


# 代理


代理也是复用类的一种方式，Java并没有提供对它的直接支持。这是继承与组合之间的中庸之道，  
因为我们将一个成员对象置于所要构造的类中，但与此同时我们在新类中暴露了该成员对象的所有  
方法。  

*[SpaceShip.java](src/extendsExample/src/com/tlxxm/learing/SpaceShip.java)*

	package com.tlxxm.learing;
	
	//飞船
	public class SpaceShip extends SpaceShipControls {
	
	    private String name;
	    public SpaceShip(String name){
	        this.name=name;
	    }
	    public String toString(){return name;}
	
	
	    public static void main(String[] args) {
	        SpaceShip protector=new SpaceShip("NSEA Protector");
	        protector.forward(100);
	    }
	}
	//飞船控制台
	class SpaceShipControls{
	    void up(int velocity){}
	    void down(int velocity){}
	    void right(int velocity){}
	    void left(int velocity){}
	    void forward(int velocity){}
	    void back(int velocity){}
	    void turboBoost(){}
	}

SpaceShip并非真正的SpaceShipControls，而是包含SpaceShipControls，但此时，SpaceShip暴露了所有SpaceShipControls的所有方法。
可通过代理解决这个问题。  
*[SpaceShipDelegation.java](src/reuseClassDelegation/src/com/tlxxm/learing/SpaceShipDelegation.java)*

	package com.tlxxm.learing;
	
	public class SpaceShipDelegation {
	
	    private String name;
	    private SpaceShipControls controls=new SpaceShipControls();
	    public SpaceShipDelegation(String name){
	        this.name=name;
	    }
	    public void up(int velocity){
	        controls.up(velocity);
	    }
	    public void down(int velocity){
	        controls.down(velocity);
	    }
	    public void right(int velocity){
	        controls.right(velocity);
	    }
	    public void left(int velocity){
	        controls.left(velocity);
	    }
	    public void forward(int velocity){
	        controls.forward(velocity);
	    }
	    public void back(int velocity){
	        controls.back(velocity);
	    }
	    public void turboBoost(){
	        controls.turboBoost();
	    }
	    public static void main(String[] args) {
		// write your code here
	    }
	}
	class SpaceShipControls{
	    void up(int velocity){}
	    void down(int velocity){}
	    void right(int velocity){}
	    void left(int velocity){}
	    void forward(int velocity){}
	    void back(int velocity){}
	    void turboBoost(){}
	}

可以看到，上面的方法是如何传递给了底层的controls对象，而其接口由此也就与使用继承得到  
的接口相同了，但是，在使用代理时，可以选择只提供在成员对象中的方法的某个子集  （只开放部分接口出去）。