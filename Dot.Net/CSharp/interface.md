# 接口

接口实际只是对一组方法签名进行了统一命名，这些方法不提供任何实现。

接口实现关系是一种**can do**的关系。

CLR的一个类型可以同时实现多个接口。

接口的继承其实就是将其他接口的协定包括到新接口中。

## 接口中的成员

除了方法，还能定义事件、属性（这些东西本质上都是方法），只是语法上的简化。

接口不能定义任何构造器方法，也不能定义任何实例字段，同时也禁止定义任何一种静态成员。

## CLR与接口

在CLR看来，接口定义就是类型定义。

也就是说CLR会为接口类型对象定义内部数据结构，再时可通过反射机制来查询接口类型的功能。

CLR要求将接口方法标记为virtual。在C#中，接口中的方法默认就是 public virtual的。

CLR允许定义接口类型的字段、参数或局部变量。

CLR允许调用Object定义的方法，因为所有类型都继承自Object。

与引用类型相似，值类型也可以实现接口，但值类型的实例在转换为接口类型时，必须装箱。  
这是由于接口变量是引用类型，必须指向堆上的对象，使CLR能检查对象的类型对象指针，从而判断
对象的确切类型。


## 隐式和显式接口方法实现

类加载到CLR中时，会为该类型创建并初始化一个方法表。 
在这个方法表中，类型引用的每个新方法（相对于继承得来的）都有对应的记录项。
另外，还为该类型继承的所有虚方法添加了记录项。

### 隐式接口方法实现

比如
````
internal sealed class SimpleType:IDisposable
{
	public void Dispose()
	{
		Console.WriteLine("Dispose");
	}
}
````

类型的方法表将包含以下方法的记录项
* Object（隐式继承的类）定义的所有虚实例方法

* IDisposable（继承的接口）定义的所有接口方法

* SimpleType引入的新方法Dispose


为了简化编程，C#编译器假定SimpleType引入的方法Dispose是对IDisposable的Dispose方法的实现。


之所以这么假定，是由于Dispose方法的可访问性是public，而此方法与SimpleType引入的方法Dispose的签名完全一致。（注：如果新方法使用virtual标记，仍然是这种假定）

C#编译器将新方法和接口方法匹配起来之后，会生成元数据，指明SimpleType类型的方法表中的两个记录项引用同一个实现。

````
SimpleType st = new SimpleType();
st.Dispose();
IDisposable d = st;
d.Dispose();
````
output
````
Dispose
Dispose
````


### 显式接口实现
````
internal sealed class SimpleType : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("SimpleType.Dispose");
    }
	//显式实现
     void IDisposable.Dispose()
    {
        Console.WriteLine("IDisposable.Dispose");
    }
}
````
output
````
SimpleType.Dispose
IDisposable.Dispose
````
在C#中，将定义方法的那个接口名称作为方法名前缀，就会创建显式接口实现（Explicit Interface Method Implementaion,**EMMI**）。

C#中不允许在定义显式接口方法时指定可访问性(public private)。

编译器在生成该方法的元数据时，可访问会自动设置为private，防止其他代码在使用类的实例时直接调用接口方法。

只有通过接口类型的变量才能调用该显式接口实现。

EMMI方法也不能标记为virtual，所以不能被重写。

这是由于EMMI方法并非真的是类型的对象模型的一部分，它只是将接口和类型连接起来，同时避免公开行为/方法。


#### 实现多个具有相同方法名和签名的接口

定义实现多个接口的类型时，这些接口可能定义了具有相同名称和签名的方法。

这时候就必须使用**显式接口方法实现**

在实现一些非泛型版本接口时，当方法参数为Object时，可以使用显式接口方法实现，

再针对某些类型（比如值类型Int32）定义一个同样的方法，这样可以减少装箱次数，还有编译时的类型安全。

在实现一些非泛型版本集合接口时，很有用。

#### 显式接口实现的几个问题

* 没有文档解释类型具体如何实现一个EMMI方法，因为是私有的
* 值类型的实例在转换成接口时装箱
* EIMI不能由派生类调用

要谨慎使用显式接口实现。

### 泛型接口

* 泛型接口提供了编译时类型安全性。

* 减少装箱次数

* 类可以实现同一个接口多次，只要每次使用不同的类型参数

* 同时接口的泛型类型参数还可标记为逆变和协变

## 接口上的扩展方法

扩展方法的一个重要特点是除了能作用于类，还能作用于接口。

对扩展方法的支持是实现LINQ的基础，通过为某些接口进行扩展方法，所有实现了这个接口的类，都可以共享这个方法。


## 设计：基类还是接口

* IS-A对比CAN-DO关系

类型只能继承一个实现。

如果派生类与基类建立不起IS-A关系，就不用基类而用接口。

接口意味着CAN-DO关系。如果多种对象类型都能做某事，应该为它们创建接口。

* 易用性

对于开发人员，定义从基类派生的新类型通常比实现接口的所有方法容易得多。

基类可提供大量功能，所以派生类可能只需稍做改动。

* 一致性实现

如果为基类提供了良好的默认实现，就使用类。

因为无论接口协定订立得有多好，都无法保证所有人100%的实现它。

* 版本控制

向基类添加一个方法，派生类将继承新方法。

而向接口添加新成员，会强迫接口的继承者更改其源代码并重新编译。


注意：两件事情实际能同时做：定义接口，同时提供实现该接口的基类。

更多请参考设计模式。


## 抽象类和接口的比较

抽象类| 接口
----|----
不能直接实例化，只能通过实例化一个派生类|不能直接实例化，只能通过实例化一个派生类
派生类要么自己是抽象的，要么必须实现所有抽象成员|实现类型必须实例化所有接口成员
可添加新的非抽象成员，可由派生类继承，且不影响版本兼容性|为接口添加额外的成员会破坏版本兼容性
可定义属性和字段|只能定义属性
成员可以是实例、虚、抽象或静态的，而且非抽象成员可提供默认实现|所有成员都被自动看成是抽象成员，不能包含任何实现
单继承|多继承