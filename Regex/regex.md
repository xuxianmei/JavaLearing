# 基本匹配
正则表达式其实就是执行搜索时的格式。
它由一些字母和数字组合而成。
例如：一个正则表达式the，它表示一个规则：
由字母t开始，接着是h，再接着是e。
"the" => The fat cat sat on **the** mat.
正则表达式是大小写敏感的, 所以The不会匹配the。

# 元字符
正则表达式主要依赖于无字符。

无字符不代表他们本身的字面意思，他们都有特殊的含义。

一些无字符写在方括号中的时候有一些特殊的意思。


元字符|描述
---|---
**.**|匹配任意单个字符除了换行符。
[ ]|字符种类，匹配方括中的任意字符。
[^ ]|否定的字符种类，匹配除了方括里的任意字符。
* | 匹配>=0个重复的在*号之前的字符。
+|匹配>=1个重复的在+号之前的字符。
？|标记?之前的字符为可选。
{n,m}|匹配num个大括号之前的字符(n<=numN=m)
(xyz)|字符集，匹配与xyz完全相等的字符串。
&#124;  |运算符或，匹配符号前或后的字符。
\|转义字符，用于匹配一些保留的字符[ ] ( ) { } . * + ? ^  $  \  &#124;
^|从开始行开始匹配。
$|从末端开始匹配。

## 点运算符（**.**）
**.**是元字符中最简单的例子。
它匹配任意单个字符，但不匹配换行符。
例如，表达式``.ar``匹配一个任意字符后面跟着是a和r的字符串。

>".ar" => The **car** **par**ked in the **gar**age.

## 字符集
字符集也叫字符类。用来指定一个范围，来匹配单个字符

### 方括号 [ ]
方括号用来指定一个字符集。
表示匹配单个字符，这个字符可以是这个字符集中的任意一个字符。

范围表示：用连字符 ``-``来指定字符集的范围。

在方括号中的字符集不关心顺序。

例如：``[Tt]he``匹配the和The

方括号中的点运行符，就代表**.**字符本身，没有特殊意义。
比如：``ar[.]``匹配``ar.``字符串。

>ar[.]" => A garage is a good place to park a c**ar.**

### 排除字符集 [^ ]


表示匹配单个字符，这个字符是除了这字符集以外的任意一个字符。

一般来说，``^``表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是
否定的。



例如：表达式``[^c]ar``匹配一个后面跟着ar的除了c的任意字符。

 >"[^c]ar" => The car **par**ked in the **gar**age

## 重复次数

后面跟着``*`` ``+`` ``?``的，用来指定匹配子模式的次数。
这些元字符在不同的情况下有着不同的效果。

### ``*`` 号
``*``号匹配 在``*``之前的字符出现大于等于0次.。

例如, 表达式``a*`` 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式``[a-z]*`` 匹配一个行中所有以小写字母开头的字符串。

>[a-z]\* => T**he car parked in the garage** #21.

`` * ``字符和 **.** 字符搭配可以匹配所有的字符  . *。

`` * ``和表示匹配空格的符号``\s``边起来用，
如表达式：``\s*cat\s*``匹配0个或更多个空格开头和0或更多个空格结尾的cat字符串。
\s\*cat\s\* => The fat** cat **sat on the con**cat**enation.

 
### + 号
``+``号匹配``+``之前的字符出现>=1次。

例如表达式c.+t匹配以首字母c开头,以t结尾，中间跟着任意个字符的字符串。
>"c.+t" => The f**at cat sat on the mat**

### ？ 号
在正则表达式中，元字符``?``标记在符号前面的字符为可选，即出现0或1次。

例如表达式[T]?he，匹配字符串he和The。

>"[T]?he" => **The** car is parked in t**he** garage.

### { } 号
在正则表达式中``{ }``是一个量词，常用来一个或一组字符可以重复的次数。

例如：表达式``[0-9]{2,3}``匹配最小2位最多3位0-9的数字。

>"[0-9]{2,3}" => The number was 9.**9997** but we rounded it off to **10**.0.

我们可以省略第二个参数，例如，``[0-9]{2,}``匹配至少两位0-9的数字。

如果逗号也省略掉，表示重复固定的次数，例如,``` [0-9]{3}`` 匹配3位数字。

>"[0-9]{2,}" => The number was 9.**9997** but we rounded it off to **10**.0.

"[0-9]{3}" => The number was 9.**9997*** but we rounded it off to 10.0.

## (...) 特征标群
特征标群是一组写在```(...)```中的子模式。

例如之前说的``{ }``是用来表示前面一个字符出现指定次数，
但如果在``{ }``前加入特征标群则表示整个标群内的字符重复N次。

例如，表达式``(ab)*``匹配连续出现0或更多个ab。

我们还可以在```( )```中用字符``|``表示或运算。

例如：``(c|g|p)ar``匹配 car gar par。

## | 或运算符（多选分支）
或运算符就表示或，用作判断条件。

一个模式可以实现横向和纵向模糊匹配。
而多选分支可以支持多个子模式任选其一。

具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。

例如 ``good|nice|great``

可视化形式如下：
![](./images/3.jpg)


>注：分支结构是惰性的，即当前面的匹配上了，后面的就不再尝试了。

## 转码特殊字符

反斜线``\``在表达式中，用于转码紧跟其后的字符。
用于指定``{ } [ ] / \ + * . $ ^ | ?``这些特殊字符。

如果想要匹配这些特殊字符，则要在其前面加上把斜线当作普通字符处理。

例如 ``.``是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的`` . ``则要写成`` \.`` 以下这个例子 ``\.?``是选择性匹配.

>"(f|c|m)at\.?" => The **fat** **cat** sat on the **mat.**

## 锚点

在正则表达式中，想要匹配指定开头或结尾的字符串就要使得到锚点。
``^``指定开头。
``$``指定结尾。

### ``^`` 号
``^``用来检查匹配的字符串是否存在所匹配字符串的开头。

例如，在``abc``中使用表达式``^a``会得到结果a。但如果使用``^b``将匹配不到任何结果。
因为字符串``abc``中并不是以b开头。

例如：^(T|t)he匹配以The或the开头的字符串。

>"^(T|t)he" => **The** car is parked in the garage.

而

>"(T|t)he" => **The** car is parked in **the** garage.

## ``$`` 号

同理于``^``号，``$``号用来匹配字符是否是最后一个。

例如：``(at\.)$匹配以at.结尾的字符串。

>"(at\.)$" => The fat cat. sat. on the m**at.*




# 简写字符集

正则表达式提供了一些常用的字符集简写。
如下：

简写|描述
---|---
**.**|除换行符以外的所有字符
``\w``|匹配所有字母数字，等同于[a-zA-Z0-9_]
``\W``|匹配所有非字母数字，即符号 等同于：``[^\w]``
``\d``|匹配数字：[0-9]
``\D``|匹配非数字：[^\d]
``\s``|匹配所有空格字符，等同于：``[\t\n\f\r\p{Z}]``
``\S``|匹配所有非空格字符：[^\s]
``\f``|匹配一个换页符
``\n``|匹配一个换行符
``\r``|匹配一个回车符
``\t``|匹配一个制表符
``\v``|匹配一个垂直制表符
``p``|匹配 ``CR/LF`` (等同于 ``\r\n``)，用来匹配 DOS 行终止符

# 前后关联约束（前后预查）

前置约束和后置约束都属于**非捕获簇**（用于匹配不在匹配列表中的格式）。

前置约束用于判断所匹配的格式是否在另一个确定的格式之后。

例如，我们想要获得所有跟在$符号后的数字。
我们可以使用正向向后约束``(?<=\$)[0-9\.]*``，
这个表达式匹配开头，之后跟着``0-9 .``，这些字符可以出现大于等于0次。

前后关联约束如下：

符号|描述
---|---
?=|前置约束-存在
?!|前置约束-排除
?<=|后置约束-存在
?<!|后置约束-排除

## ```?=...``` 前置约束（存在）
```?=...``` 前置约束（存在），表示第一部分表达式必须跟在```?=...```定义的表达式之后。

返回结果只满足第一部分表达式。
定义一个前置约束（存在）要使用``( )``，在括号内部使用一个问号和等号：``(?=...)``。

前置约束的内容写在括号中的等后后面。

例如：表达式``(T|t)he(?=\sfat)``匹配The和the，在括号中我们又定义了前置约束（存在），
``(?=\sfat)，即The和the后面紧跟着``(空格)fat``
>"(T|t)he(?=\sfat)" => **The** fat cat sat on the mat.

## ```?!...``` 前置约束（排除）
``?!`` 前置约束（排除），用于筛选所有匹配结果，筛选条件为其后不跟随定义的格式。
前置约束（排除）定义和前置约束（存在）一样，区别就是=替换成!，也就是```(?!...)```

表达式```(T|t)he(?!\sfat)```匹配The和the，且后不跟着 ``(空格)fat``

>"(T|t)he(?!\sfat)" => The fat cat sat on **the** mat.

## ```?<=...```后置约束（存在）

```?<=...```后置约束（存在）记作```(?<=...)```用于筛选所有匹配结果。
筛选条件为其前跟随着定义的格式。

例如：表达式```(?<=(T|t)he\s)(fat|mat)匹配fat和mat，且前跟着The或the。

>"(?<=(T|t)he\s)(fat|mat)" => The **fat** cat sat on the **mat**.


## ```?<!...```后置约束（排除）
```?<!...```后置约束（排除）记作``(?<!...)``，用于筛选所有匹配结果，
筛选条件为前不跟着定义的格式。

例如：表达式``(?<!(T|t)he\s)(cat)``，匹配cat，且其前不跟着The或the。

>"(?<!(T|t)he\s)(cat)" => The cat sat on **cat**.

# 标志(FLAGS)
标志也叫修饰语，因为它可以用来修改表达式的搜索结果。
这些标志可以任意的组合使用。

标志|描述
i|忽略大小写
g|全局搜索
m|多行的:锚点元字符``^`` ``$``工作范围在每行的起始。
注：下面的表达式，要注意 前面的一个``/``和后面的``/``,TODO
## 忽略大小写（Case Insensitive）
修饰语``i``用于忽略大小写。
例如，表达式```/The/gi```，表示全局搜索``The``，在后面的``i``将其条件修改为忽略大小写，则变成搜索the和The，``g``表示全局搜索。



>"/The/gi" => **The** fat cat sat on **the** mat.

## 全局搜索(Global search)

修饰符 ``g`` 常用语执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 ``/.(at)/g`` 表示搜索 任意字符(除了换行) + at, 并返回全部结果。

>"/.(at)" => The **fat** cat sat on the mat.

>"/.(at)/g" => The **fat** **cat** sat on the **mat**.

## 多行修饰符(Multiline)
多行修饰符``m``常用语执行一个多行匹配。
像之前介绍的`` ^``  ``$`` 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符``m``。

例如, 表达式 ``/at(.)?$/gm`` 表示小写字符 a 后跟小写字符 t , 末尾可选除换行符外任意字符. 根据 m 修饰符, 现在表达式匹配每行的结尾.



>"/.at(.)?$/" =>
>The fat
>cat sat
>on the **mat**.



>"/.at(.)?$/gm" =>
>The **fat**
>cat **sat**
>on the **mat**.

# 贪婪匹配和惰性匹配(Greedy VS Lazy matching)
正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ``?``,
 将贪婪匹配模式转化为惰性匹配模式。

>"/(.*at)/" => **The fat cat sat on the mat.** 

>"/(.*?at)/" => **The fat** cat sat on the mat. 

通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：

惰性量词|贪婪量词
---|---
{m,n}?| {m,n}
{m,}? |{m,}
?? |?
+? |+
*? |*