## 类型和成员基础

### 类型的各种成员

类型中定义了0-n个以下种类的成员。

* 常量
常量是指出数据值恒定不变的符号，常量总与类型关系，不与类型的实例关联。常量逻辑上总是静态成员。

* 字段
字段表示只读或可读/可写的数据值。
静态字段：被认为是类型状态的一部分
实例字段：被认为是对象状态的一部分

* 实例构造器
将新对象的实例字段初始化为良好初始状态的特殊方法。

* 类型构造器（静态构造器）
将类型的静态字段初始化为良好初始状态的特殊方法。

* 方法
更改或查询类型或对象状态的函数。
分为静态方法和实例方法

* 操作符重载
实际就是方法
定义了当前操作符作用于对象时，应该如何操作该对象。

* 转换操作符
实际就是方法
定义如何隐式或显示将对象从一种类型转型为另一种类型的方法

* 属性
实际就是方法
属性允许用简单的、字段风格的语法设置或查询类型或对象的逻辑状态。
分为静态属性和实例属性
属性可以无参，也可以有多个参数。

* 事件
事件包含两个方法，来登录和注销对此事件在关注，另外还有一个委托字段来维护登记的方法集。

* 类型
类型可以定义其他嵌套类型。


编译器必须为以上的每种成员都生成元数据和IL代码。
正是由于有了元数据，用一种语言写的代码才能无缝的访问用另一种语言的代码。

CLR还利用公共元数据格式决定这些成员在运行时的行为。


### 类型的可见性

定义类型的文件范围，可将类型的可见性指定为public和internal。
public：除了对本程序集中的所有代码可见，还对其他程序集中的代码可见
internal：只对本程序集中的所有代码可见。

定义了internal可见性以后，如果想指定对某些程序集可见，可以通过声明友元程序集来实现。
InternalIsVisableTo


### 成员的可访问性

定义类型的成员时（包括嵌套类型），可指定成员的可访问性。
在代码中引用成员时，成员的可访问性指出引用是否合法。
在这一方面，编译器和JIT都提供了验证。

可访问修饰符

* public
成员可由任何程序集的任何方法访问
* protedted internal
成员可由任何嵌套类型、任何派生类型（即使在别的程序集）或者定义程序集中的任何方法访问。
* internal
成员只能由定义程序集中的方法访问
* protected
只能由定义类型、任何嵌套类型、或不管在什么程序中的派生类型中的方法访问
* private
成员只能由定义类型或者 任何嵌套类型中的方法访问

C#默认所有成员都是private的

CLR要求接口类型的所有成员都是public的可访问性，但C#编译器知道这一点，所以不需要显式声明。

C#编译器要求在派生类型中重写类型定义的成员时，原始成员和重写成员具有相同的可访问性。

CLR允许放宽但不允许收紧成员的可访问性的限制。

这是因为CLR承诺派生类总能转型为基类，并获取对基类成员的访问权。

### 静态类

不需要实例化的类，这种类的唯一作用就是组合一组相关的成员。
在C#中，要用static关键字定义不可实例化的类。
该关键字只能应用于类，不能应用于结构。 
因为CLR总是允许值类型实例化。

C#编译器对静态类进行了如下限制

* 静态类必须直接从基类System.Object派生，从任何其他类派生都没有意义。
* 静态类不能实现任何接口，这是因为只有使用类的实例时，才可以调用类的接口方法。
* 静态类只能定义静态成员（字段、方法、属性和事件）
* 静态类不能作为字段、方法参数或局部变量使用。

使用static关键字定义的类，编译器会将该类标记为abstract和sealed。

### CLR如何调用虚方法、属性和事件

C#默认方法为非虚方法。除非使用virtual声明。
属性和事件实际也是作为方法实现的。


编译器会记录类型的方法定义表，用一组flag指明方法是实例方法、虚方法还是静态方法，根据这些来判断应如何生成IL代码来正确调用方法。

CLR提供了两个方法调用指令

* **call**
该IL指令可调用静态方法、实例方法和虚方法。
	* 用call指令调用静态方法
必须指定方法的定义类型。

	* 用call指令调用实例方法和虚方法
必须指定引用了对象的变量，call指令假定该变量不为null。这个变量本身的类型指明了方法的定义类型。	如果变量的类型没有定义该方法，就检查基类型来查找匹配方法。	call指令经常用于以非虚方法调用虚方法。

* **callvirt**
该IL指令可调用实例方法和虚方法，不能调用静态方法。
用callvirt指令调用实例方法或虚方法，必须指定引用了对象的变量，变量的类型指定了方
法的定义类型。
	* 用callvir指令调用非虚实例方法
变量类型指明了方法的定义类型
	* 用callvirt指令调用虚实例方法
CLR检查发出调用的对象的实际类型，然后以多态方式调用方法。
为了确定类型，发出调用的变量绝对不能为null。
也就是说，编译这个调用时，JIT编译器会生成代码来验证变量的值是不是null。
正是由于这种额外的检查，所以callvirt指令的执行速度比call指令秒慢。
注意：即使callvirt指令调用的是非虚实例方法，也要执行这种检查。


C#认为,JIT编译器就生成代码来验证发出调用的对象不为null。所以C#用callvirt指令调用
所有实例方法（虚和非虚），这意味着，相对call，调用非虚实例方法的调用要稍慢一点。


编译器有时用call而不是callvirt调用虚方法。比如：

````
public class Man {
	public override string ToString()
	{
	    return base.ToString();
	}
}
````

调用虚方法base.ToString()时，C#编译器生成call指令，来确保以非虚方式来调用基类的ToString()方法。  
因为如果以虚方式调用base.ToString()，调用会递归执行，直到线程栈溢出。


无论用call还是callvirt调用实例方法或虚方法，这些方法通常接收隐藏的this实参作为方法的第一个参数。this实参引用要操作的对象。


注：一旦将某个方法、属性或事件设为virtual，基类就会丧失对它的行为和状态的部分控制权。

### 版本控制

C#提供了5个影响组件版本控制的关键字，可将它们应用于类型以及类型成员。

``C#关键字`` | ``应用于类型`` | ``应用于方法/属性/事件`` |``常量/字段``
---|---|---|---
abstract|表示不能构造该类型的实例|表示为了构造派生类型的实例，派生类型必须重写并实现这个成员|不允许应用
virtual|不允许应用|表示这个成员可由派生类型重写|不允许应用
override|不允许应用|表示派生类型正在重写基类型的成员|不允许应用
sealed|表示该类型不能用作基类型|表示这个成员不能被派生类型重写，只能将该关键字用于重写虚方法的方法|不允许应用


new用于版本控制时，应用于嵌套类型、方法、属性、事件、常量或字段时，表示该成员与基类中的相似的成员无任何关系。

