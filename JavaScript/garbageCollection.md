## 垃圾回收

javascript自动管理内存。

### 可达性

JavaScript中主要的内存管理概念是可达性。
『可达』值是那些以某种方式可访问或可用的值。它们保证存储在内存中。

这里列出固有的可达值基本集合，这些值明显不能被释放。

比方说：
* 当前函数的局部变量和参数。
* 嵌套调用时，当前调用链上所有函数的变量与参数。
* 全局变量。
* （还有一些内部的）

这些值被称作根。

如果一个值可以通过引用或引用链，从根值访问到，则认为这个值是可达的。

比方说，如果局部变量中有一个对象，并且该对象具有引用另一个对象的 property，则该对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。

在 JavaScript 引擎中有一个被称作垃圾回收器的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的（内存释放）。

## 垃圾回收算法

垃圾回收的基本算法被称为 “mark-and-sweep”。

定期执行以下“垃圾回收”步骤：

* 垃圾收集器找到所有的根，并“标记”它们。
* 然后它遍历并"标记"来自它们的所有引用。
* 然后它遍历到标记的对象并标记他们的引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
* 直这样，直到有未访问的引用（从根访问到）。
 

没有被标记的所有对象都被删除。

JavaScript 引擎做了许多优化，使其运行速度更快，并且不会影响代码运行。

一些优化点：

* 分代收集 —— 对象被分成两组：『新的』和『旧的』。许多对象出现，完成他们的工作并快速释放，他们可以很快被清理。那些长期存活下来的对象会变得『老旧』，而且检查的次数也会减少。
* 增量收集 —— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分逐一处理。这需要他们之间额外的标记来追踪变化，但是会有许多微小的延迟而不是大的延迟。
* 闲时收集 —— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
* 

现代引擎实现了垃圾回收的高级算法。

有一本通用的书，叫《The Garbage Collection Handbook: The Art of Automatic Memory Management》（R. Jones 等人著）讲到了一些。

如果你熟悉低级编程，关于 V8 引擎垃圾回收器的更详细信息请参阅文章 [V8 的垃圾回收：垃圾回收](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)。

V8 博客还不时发布关于内存管理变化的文章。当然，为了学习垃圾收集，你最好通过学习 V8 引擎内部知识来进行准备，并阅读一个叫 [Vyacheslav Egorov](https://mrale.ph/) 的 V8 引擎工程师的博客。我之所以说『V8』，因为它最容易在互联网上找到文章。对于其他引擎，许多方法是相似的，但在垃圾收集上许多方面有所不同。