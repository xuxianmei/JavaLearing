# 用电信号传输TCP/IP数据——探索协议栈和网卡

## 创建套接字

### 协议栈的内部结构

本章我们将探索操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何
将浏览器的消息发送给服务器的。

和浏览器不同的是，协议栈的工作我们从表面上是看不见的。

协议栈的内部如下图所示，分为几个部分，分别承担不同的功能。

这张图中的上下关系是有一定规则的，上面的部分会向下面的部分委派工作，
面的部分接受委派的工作并实际执行。

![](images/2.1.png)


当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下
关系相反的情况。

下面我们从上到下来看一遍。

图中最上面的部分是网络应用程序，也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分来完成。

当然，除了浏览器之外，其他应用程序在网络上收发数据的操作也都是类似上面这样的，也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。

因此，下面介绍的内容不仅适用于浏览器，也适用于各种应用程序。

应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS
服务器发出查询，它的工作过程我们在第 1 章已经介绍过了。

再下面就是操作系统内部了，其中包括协议栈。
协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP
协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。

下面一半是用 IP 协议控制网络包收发操作的部分。
在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给
通信对象的操作就是由 IP 来负责的。

此外，IP 中还包括 ICMP 协议和 ARP 协议。

ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息。
ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作
，也就是对网线中的信号执行发送和接收的操作。

### 套接字的实体就是通信控制信息

对于在数据收发扮演关键角色的套接字，让我们看一看它具体是个怎么的东西。

在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的
控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态等。

本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，
我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字
的实体。

协议栈在执行操作时需要参阅这些控制信息。

例如，在发送数据时，需要看一看套接字中的通信对象IP地址和端口号，以便向指定的
IP地址和端口发送数据。

在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途
丢失，永远也等不到对方的响应。

在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，
这就需要协议栈能够知道执行发送数据操作后过了多长 时间。

为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能
根据这些信息按照需要执行重发操作。

>协议栈是根据套接字中记录的控制信息来工作的。

上面的都是抽象概念。

下来来看看真正的套接字示例。

在 Windows 中可以用 netstat 命令显示套接字内容：

![](images/2.2.png)

图中每一行相当于一个套接字，当创建套接字时，就会在这里增加一行新
的控制信息，赋予“即将开始通信”的状态，并进行通信的准备工作，如
分配用于临时存放收发数据的缓冲区空间。

>对于处于等待连接状态的套接字，也可以绑定 IP 地址，如果绑定了 IP 地址，
那么除绑定的 IP 地址之外，对其他地址进行连接操作都会出错。
当服务器上安装有多块网卡时，可以用这种方式来限制只能连接到特定的网卡。

### 调用socket时的操作

看过套接字的具体样子之后，我们的探索之旅将继续前进，看一看当浏览器调用 
socket 、connect等 Socket 库中的程序组件时，协议栈内部是如何工作的。

>socket：大写字母开头的 Socket 表示 Socket 库，而小写字母开头的 socket
表示 Socket 库中名为 socket 的程序组件。

首先，我们再来看一下浏览器通过 Socket 库向协议栈发出委托的一系
列操作。



正如我们之前讲过的那样，浏览器委托协议栈使用 TCP 协议来收发数据，
因此下面的讲解都是关于 TCP 的。

![](images/2.3.png)

首先是创建套接字的阶段:应用程序调用socket申请创建套接字，协议栈根据应用
程序的申请执行创建套接字的操作。

在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。

用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出
 这样一块空间来，这相当于为控制信息准备一个容器。
 
 但光有一个容器并没有什么用，还需要往里面存入控制信息。
 
 套接字刚刚创建时，数据收发操作还没有开始。
 
 因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。
 
 到这里，创建套接字的操作就完成了。
 
 >创建套接字时，首先分配一个套接字所需的内存空间，然后向其
中写入初始状态。

接下来，需要将表示这个套接字的描述符告知应用程序。


收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。

由于套接字中记录了通信双方的信息以及通信处于怎样的状态，
所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，
这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。

## 连接服务器

### 连接是什么意思

创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈
会将本地的套接字与服务器的套接字进行连接。

话说，以太网的网线都是一直连接的状态，我们并不需要来回插拔网线，
那么这里的“连接”到底是什么意思呢？
连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备
数据收发的一连串操作。

连接到底是什么？
---

套接字刚刚创建完成时，当应用程序委托发送数据的时候，协议栈会如何操作呢？
套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。

浏览器可以根据网址来查询服务器的 IP 地址，而且根据规则也知道应该使用 80
号端口，但只有浏览器知道这些必要的信息是不够的。

因为在调用 socket 创建套接字时，这些信息并没有传递给协议栈。
因此，我们需要**把服务器的IP地址和端口号等信息告知协议栈**。

这是连接操作的目的之一。

服务器这边又是怎样的情况呢？

服务器上也会创建套接字，但服务器上的协议栈和客户端一样，
只创建套接字是不知道应该和谁进行通信的。

和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。

于是，我们需要**让客户端向服务器告知必要的信息**，
比如“我想和你开始通信，我的 IP 地址是 `xxx.xxx.xxx.xxx`，端口号是 `yyyy`。”

可见，**客户端向服务器传达开始通信的请求**，也是连接操作的目的之一。

连接实际上是**通信双方交换控制信息，在套接字中记录这些必要信息，并准备数据
收发的一连串操作**。

上面提到的客户端将IP地址和端口号告诉服务器这样的过程，就属于交换控制
信息的一个具体的例子。

所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP地址和端口号就是典型的例子。

连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则进行连接操作，
双方就可以得到必要的信息从而完成数据收发的准备。

此外，当执行数据收发操作时，我们还需要**一块用来临时存放要收发的数据的内存空间**，
这块内存空间称为缓冲区，这也是在连接操作的过程中分配的。

上面这些就是连接这个词代表的具体含义。

>使用“连接”这个词是有原因的。通信技术的历史已经有 100 多年，从通
信技术诞生之初到几年之前的很长一段时间内，电话技术一直都是主流。
而电话的操作过程分为三个阶段：（1）拨号与对方连接；（2）通话；（3）挂
断。人们将电话的思路套用在现在的计算机网络中了，所以也就自然而然
地将通信开始之前的准备操作称为“连接”了。如果没有这段历史的话，
说不定现在我们就不叫“连接”而是叫“准备”了。因此，如果觉得“连
接”这个词听起来有些怪，那么用“准备”这个词来替换也问题不大。

### 负责保存控制信息的头部

关于控制信息，其实可以大体上分为两类：

第一类是客户端和服务器相互联络时交换的控制信息。
第二类是那就是保存在套接字中，用来控制协议栈操作的信息。


客户端和服务器相互联络时交换的控制信息
---
这些信息，不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程都需要，
这些内容在TCP协议的规格中进行了定义。

如下表所示：

![](images/table2.1.png)

表中的这些字段就是TCP规格中定义的控制信息。

这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行
通信时，都需要提供这些控制信息。

这些信息会被添加在客户端与服务器之间传递的网络包的开头。
在连接阶段，由于数据收发还没有开始，所示网络包中没有实际的数据，只有控制信息。

这些控制信息位于网络包的开头，因此被称为**头部**。
此外，以太网和 IP 协议也有自己的控制信息，这些信息也叫头部，
为了避免各种不同的头部发生混淆，我们一般会记作 TCP 头部、MAC 头部 、IP 头部。

>头部是用来记录和交换控制信息的



用来控制协议栈操作的信息
---

应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，
还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据
这些信息来执行每一步的操作。


我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，
因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同 ，但这并没有什么问题。
因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要
的信息写入头部，客户端和服务器之间的通信就能够得以成立。

>通信操作中使用的控制信息分为两类。
（1） 头部中记录的信息
（2） 套接字（协议栈中的内存空间）中记录的信息


### 连接操作的实际过程

这个过程是从应用程序调用 Socket 库的 connect 开始的。

```
connect（< 描述符 >, < 服务器 IP 地址和端口号 >,  … ）
```
上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP
模块。

然后协议栈中的TCP模块会与该IP地址对应的对象，也就是与服务器中的TCP模块交换
控制信息。

首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。
然后，将头部中的控制位的SYN设置为1，此外还需要设置适当的序号窗口大小。


当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块，并委托它进行发送。

IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的IP
模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口
号对应的套接字。
也就是说，从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接
字就可以了。

上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在
TCP头部中设置发送方和接收方端口号及SYN标志位。在返回响应时还需要将 ACK 控制位设为1  ，这表示已经接收到相应的网络包。

最后，经过网络和IP模块到达客户端TCP模块，客户要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。
当这个服务器收到这个返回包之后，连接操作才算全部完成。


现在，套接字就已经进入随时可以收发数据的状态了。

只要数据传输过程在持续，也就是在调用 close 断开之前，连接是一直存在的。

建立连接之后，协议栈的连接操作就结束了，也就是说 connect 已经执行完毕，
控制流程被交回到应用程序。

## 收发数据

### 将HTTP请求消息交给协议栈


当控制流程从connect回到应用程序之后，接下来就进入数据收发阶段了。

数据收发操作是从应用程序调用wirte将要发送的数据交给协议栈开始的，
协议栈收到数据后执行发送操作。

这一操作包含如下要点：

首先，协议栈交不关心应用程序传来的数据是什么内容。
应用程序在调用write时会指定发送数据的长度，在协议栈看来，要发送的数据是
一定长度的二进制字节序列而已。

其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区
中，并等待应该程序的下一段数据。

这样做是有道理的，应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，

同的应用程序在实现上有所不同，有些程序会一次性传递所有的数据，有
些程序则会逐字节或者逐行传递数据。

总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。
在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包
，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论
，但都是根据下面几个要素来判断的：

第一个判断要素是每个网络包能纳的数据长度，协议栈会根据一个叫作MUT的参数来
进行判断。

MTU表示一个网络包的最大长度，在以太网中一般是1500字节。

MTU 是包含头部的总长度，因此需要从
MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大
数据长度，这一长度叫作 MSS。

当从应用程序收到的数据长度超过或者接
近 MSS 时再发送出去，就可以避免发送大量小包的问题了。

MTU：Maximum Transmission Unit，最大传输单元。
>MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
MSS：除去头部之后，一个网络包所能容纳的 TCP 数据的最大
长度。

另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如
果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，
即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。
为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。


除了依靠协议栈本身来判断发送的时机，协议栈也给应用程序保留了控制发送时机的余地。

应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，
则协议栈就会按照要求直接发送数据。

像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，
因此一般会使用直接发送的选项。