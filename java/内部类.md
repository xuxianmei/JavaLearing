可以将一个类的定义放在另一个类的定义内部，这就是内部类。

# 创建内部类

把类的定义置于外围类的里面。
最简单的演示：



*[Parcel1.java](src/innerClass/src/com/tlxxm/learing/Parcel1.java)*

	package com.tlxxm.learing;
	
	public class Parcel1 {
	    class Contents{
	        private int i=11;
	        public int value(){
	            return i;
	        }
	    }
	    class Destination{
	        private String label;
	        Destination(String whereTo){
	            label=whereTo;
	        }
	        String readLabel(){
	            return label;
	        }
	    }
	    //在Parcel1中使用内部类，就像使用其它类一样。
	    public void ship(String dest){
	        Contents c=new Contents();
	        Destination d=new Destination(dest);
	        System.out.println(d.readLabel());
	    }
	    public static void main(String[] args) {
	        Parcel1 p=new Parcel1();
	        p.ship("Beijing");
	    }
	}	
	

上面的代码中，在Parcel1的方法ship()里面使用内部类时，与使用其它外部类没有任何不同。
在这里，实际的只是内部类的名字是嵌套在Parcel1里面。

更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用。


*[Parcel1.java](src/innerClass/src/com/tlxxm/learing/Parcel1.java)*
	
	package com.tlxxm.learing;
	
	public class Parcel2 {
	    class Contents{
	        private int i=11;
	        public int value(){
	            return i;
	        }
	    }
	    class Destination{
	        private String label;
	        Destination(String whereTo){
	            label=whereTo;
	        }
	        String readLabel(){
	            return label;
	        }
	    }
	    public Contents contents(){
	        return new Contents();
	    }
	    public Destination to(String s){
	        return new Destination(s);
	    }
	
	    //在Parcel1中使用内部类，就像使用其它类一样。
	    public void ship(String dest){
	        Contents c=contents();
	        Destination d=to(dest);
	        System.out.println(d.readLabel());
	    }
	    public static void main(String[] args) {
	        Parcel2 p=new Parcel2();
	        p.ship("Beijing");
	        Parcel2 q=new Parcel2();
	        //声明指向内部类的对象的引用
	        Parcel2.Contents c=q.contents();
	        Parcel2.Destination d=q.to("Shanghai");
	
	    }
	}

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，都必须像main()方法一样，
具体地指明这个对象的类型：OuterClassName.InnerClassname。

# 链接到外部类

当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围  
对象的所有成员，而不需要任何特殊条件。
此外，内部类还拥有其外围类的所有元素的访问权。

*[Sequence.java](src/innerClass3/src/com/tlxxm/learing/Sequence.java)*

	
	package com.tlxxm.learing;
	
	public class Sequence {
	    private Object[] items;
	    private int next=0;
	    public Sequence(int size){
	        items=new Object[size];
	    }
	    public void add(Object x){
	        if(next<items.length)
	            items[next++]=x;
	    }
	    private class SequenceSelector implements Selector{
	        private int i=0;
	        public boolean end(){
	            return i== items.length;
	        }
	        public Object current(){
	            return items[i];
	        }
	        public void next(){
	            if(i<items.length)
	                i++;
	        }
	    }
	    public Selector selector(){
	        return new SequenceSelector();
	    }
	
	    public static void main(String[] args) {
	        Sequence sequence=new Sequence(10);
	        for(int i=0;i<10;i++){
	            sequence.add(Integer.toString(i));
	        }
	        Selector selector=sequence.selector();
	
	        while(!selector.end()){
	            System.out.print(selector.current()+" ");
	            selector.next();
	        }
	    }
	}
	interface Selector{
	    boolean end();
	    Object current();
	    void next();
	}
	
**Output：**
>0 1 2 3 4 5 6 7 8 9 

Sequence类只是一个固定大小的Object的数组，以类的形式包装起来。

SequenceSelector中的方法都用到了items，这是一个引用，它并不是SequenceSelector的  
一部分，而是外围类中的一个private字段。
然后内部类可以访问其外围类的方法和字段，就像自己拥有它们似的。

所以内部 类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？
当某个外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那  
外围类对象的引用 。  
然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。

内部类的对象只能在与其外围类的对象相关联的情况下才能被创建。  
构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。

# 使用.this与.new

如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。  
这样产生的引用自动地具有正确的类型。
这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。



*[DotThis.java](src/innerClass4/src/com/tlxxm/learing/DotThis.java)*


	package com.tlxxm.learing;
	
	public class DotThis {
	    void f(){
	        System.out.println("DotThis.f()");
	    }
	    public class Inner{
	        public DotThis outer(){
	            return DotThis.this;//返回当前外围类的对象
	        }
	    }
	    public Inner inner(){
	        return new Inner();
	    }
	
	    public static void main(String[] args) {
		    DotThis dt=new DotThis();
		    DotThis.Inner dti= dt.inner();
		    dti.outer().f();
	
		    DotNew dn=new DotNew();
		    DotNew.Inner dni=dn.new Inner();//在外部创建内部类Inner的对象
	    }
	}
	class DotNew{
	    public class Inner{
	
	    }
	}


在其他类中创建内部类对象，必须使用.new的语法，.new提供了此内部类的外围类对象的引用。
要想直接创建内部类的对象，不能按照想象的方式，去引用外部类的名字DotNew，而是必须使用外部类  
的对象来创建该内部类对象（因为内部类需要有一个外围类对象的引用存在）。  
这也就解决了内部类名字作用域的问题。

在拥有外部类对象之前是不可能创建内部类对象的。  
这是因为内部类对象会暗暗地连接到创建它的外部类对象上。
但是，如果创建的是静态内部类，就不需要对外部对象的引用。


# 内部类与向上转型

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。
（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）  

这是因为此内部类————某个接口的实现————能够完全不可见，并且不可用。所得到的只是指向基类或
接口引用，所以能够很方便的隐藏实现细节。

*[TestParcel.java](src/innerClass5/src/com/tlxxm/learing/TestParcel.java)*

	package com.tlxxm.learing;
	
	
	public class TestParcel {
	
	    public static void main(String[] args) {
	        Parcel4 p=new Parcel4();
	        Contents c=p.contents();//获取内部类实现的接口
	        System.out.println(c.value());
	
	        Destination d=p.destination("Beijing");
	        System.out.println(d.readLabel());
	        //Parcel4.PContents pc=p.new PContents(); 此处操作不合法，因为PContents是private修饰的，但是并不影响它实现的接口。
	
	    }
	}
	
	
	interface Destination{
	    String readLabel();
	}
	interface Contents{
	    int value();
	}
	class Parcel4{
	    //内部类
	    private class PContents implements Contents{
	        private int i=1;
	        @Override
	        public int value(){
	            return i;
	        }
	    }
	    //内部类
	    protected class PDestination implements Destination{
	        private String label;
	        private PDestination(String whereTo){
	            label=whereTo;
	        }
	        public String readLabel(){
	            return label;
	        }
	    }
	    public Destination destination(String s){
	        return new PDestination(s);
	    }
	    public Contents contents(){
	        return new PContents();
	    }
	}

内部类PContents是private，所以除了Parcel4，没有人能访问它，PDestination是protected，
所以只有Parcel4及其子类，还有与Parcle4同一个包中的类（因为proteced也给予了包访问权）。

于是private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，  
并且完全隐藏了实现的细节。

# 在方法和作用域内的内部类

上面都是内部类的典型用途，但内部类的语法覆盖了大量的其他更加难以理解的技术。
例如，可以在一个方法里面或者在任意的作用域内定义内部类。
这么做有两个理由：
1. 实现某个类型的接口，于是可以创建并返回对其的引用。
2. 要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但又不希望这个类是公共可用的。

* 在方面的作用域内（而不是在其他类的作用域内）创建一个完整的类，这被称作局部内部类

*[Parcel5.java](src/innerClass6/src/com/tlxxm/learing/Parcel5.java)*

	package com.tlxxm.learing;
	interface Destination{
	    String readLabel();
	}
	public class Parcel5{
	    public Destination destination(String s){
	        //内部类
	        class PDestination implements Destination{
	            private String label;
	            private PDestination(String whereTo){
	                label=whereTo;
	            }
	            public String readLabel(){
	                return label;
	            }
	        }
	        return new PDestination(s);
	    }
	
	    public static void main(String[] args) {
	        Parcel5 p=new Parcel5();
	        Destination d=p.destination("Beijing");
	    }
	}
PDestination类是destination()方法的一部分，而不是Parcel5的一部分。
所以在destination()之外不能访问PDestination。
此方法返回类型是Destination，所以return时是向上转型的。

可以在任何作用域内，嵌入一个内部类定义，但在作用域之外，它是不可用的，除此之外，它与普通的  
类一样。

# 匿名内部类

*[Parcel7.java](src/anonymousInnerClass/src/com/tlxxm/learing/Parcel7.java)*

	package com.tlxxm.learing;
	
	interface IContents{
	    int value();
	}
	public class Parcel7 {
	
	    public IContents contents(){
	        //实现了接口IContents的匿名内部类
	        return new IContents() {
	            private int i=11;
	            @Override
	            public int value() {
	                return i;
	            }
	        };//分号记得加上
	    }
	
	    public static void main(String[] args) {
	        Parcel7 p=new Parcel7();
	        IContents c=p.contents();
	        System.out.println(c.value());
	    }
	}


contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起。
这个类是匿名的，它没有名字。
这和语法指的是：创建一个继承自IContents接口的匿名类。通过new表达式返回的引用被自动  
向上转型为对IContents的引用。

上述匿名内部类的语法是下述形式的简化形式：
*[Parcel7.java](src/anonymousInnerClass/src/com/tlxxm/learing/Parcel7.java)*

	//与Parcel7中 contents方法相同的效果
	class Parcel7b{
	    class MyContents implements IContents{
	        private int i=11;
	        @Override
	        public int value(){
	            return i;
	        }
	    }
	    public IContents contents(){
	        return new MyContents();
	    }
	}
