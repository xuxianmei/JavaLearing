# 基本概念

## 构造器

在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。
在初始化期间自动调用构造器，构造器与类名称相同。
使用new创建对象时，将为对象分配存储空间，并调用相应的构造器。
## 默认构造器
不接受任何参数的构造器叫做默认构造器（无参构造器） 。
如果类中没有构造器，编译器会自动创建一个默认构造器。

从概念上讲，初始化与创建是彼此独立的，但在Java中，初始化与创建捆绑在一起，两者不能  
分离。

任何设计语言都具备的一项重要特性就是对名字的运用，当创建一个对象时，也就给此对象分配到  
的存储空间取了一个名字。  
所谓方法则是给某个动作取的名字。通过使用名字，可以引用所有的对象和方法。

### 重载
>在java（和C++）里，构造器是强制重载方法名的另一个原因。
>既然构造器的名字已经由类名所决定，就只能有一个构造器名。
>那么想要用多种方式创建一个对象时就需要其它的构造器来构造对象。
>为了让方法名相同而形式参数不同的构造器同时存在，必须方法重载。

>如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。

###  在构造器中调用构造器

>通过在一个构造器中调用另一个构造器，可以复用代码。
>在构造器中，如果为this添加了参数列表，将产生对符合此参数列表的某个构造器  
>的明确引用。
>调用方式：**this(参数1，参数2,...)**
	
注：仅能使用this调用一个构造器，且必须是构造器内的第一行有效代码。  





## this关键字

this关键字只能在方法内部使用，表示对"调用方法的那个对象"的引用。  
this的用法和其他对象引用并无不同。
如果在方法内部调用同一个类的另一个方法，不必使用this，直接调用即可。
当前方法中的this引用会自动应用于同一类中的其他方法。

this关键对于将当前对象传递给其他方法也很有用：将this作当作普通引用使用，作为其它类中方法的参数。 

	package com.tlxxm.learing;

	public class Main {
	
	    public static void main(String[] args) {
		    new Person().eat(new Apple());
	    }
	}
	//人
	class Person{
	    public void eat(Apple apple){
	        Apple peeled=apple.getPeeled();
	        System.out.println("yummy");
	    }
	}
	//削皮器
	class Peeler{
	    static Apple peel(Apple apple){
	        return apple;
	    }
	}
	//苹果
	class Apple{
	    Apple getPeeled(){
	        return Peeler.peel(this);
	    }
	}
  

### static的含义
只可应用于类内声明的成员，不可应用于局部变量。
代表此成员属于类，不单独属于某个对象。
注：static方法没有this代表的引用。  
在static方法的内部不能调用非静态方法（因为没有this），但反过来可以。
  


# 初始化

## 普通成员初始化
此处针对都是类内的成员非方法内的局部变量。
注：**_方法内的局部变量，如果使用前，没有进行初始化，编译器会提示错误消息，因为编译器不会为其提供默认值。_**

Java尽力保证：所有变量在使用前都能得到恰当的初始化。


### 自动初始化
* 基本类型
	>类的每个基本数据类型成员，在没有被初始化时，都会获得基本类型的标准初值 。
* 对象引用
	>如果不将其初始化，此引用就会获得一个特殊值null。



### 指定初始化
在定义成员变量的地方，直接使用赋值操作符进行初始化。

### 显示初始化
使用类似实例初始化的语法，来初始化每一个对象的非静态变量。

	class Point{	  	
	    int x;
	    int y;
	    {
	        x=1;
	        y=2;
	        System.out.println("显示初始化：x="+x+",y="+y);
	    }	  
	}  

这种语法对于支持“匿名内部类”的初始化是必须的，也使得可以保证无论调用了哪个显式构造器，  
某些操作都会发生。

### 构造器初始化
在构造器内部使用赋值操作符操作符进行赋值初始化，但在构造器被调用之前，  
自动初始化或指定初始化会先被执行。





## 静态数据的初始化

无论创建多少个对象，静态数据都只占用一份存储区域。

### 自动初始化

* 基本类型  
	>如果没有对它进行初始化，会获得基本类型的标准初值
* 对象引用  
	>如果没有对它进行初始化，就得到null作为初始值。

### 指定初始化（定义处）

与非静态数据操作方法一致，使用赋值操作符进行赋值。

### 显示初始化

将多个静态初始化操作组成一个静态块。  

	class Point{
	    static int i;
	    static{
	        i=47;
	        System.out.println("静态成员显示初始化：i="+i);
	    }
	}
这段代码只是一段跟在static关键字后面的代码，仅执行一次。

静态数据只在第一次创建该类的对象，或者该类的静态数据时，才会被初始化，此后，
静态对象不会再次被初始化。




## 初始化顺序

### 大规则
先静态成员，而后是非静态成员 
### 小规则   
成员变量定义的先后顺序决定了初始化的顺序。
先使用自动初始化或者指定初始化，再使用显示初始化，最后是构造器里的初始化。

# 清理：终结处理和垃圾回收

垃圾回收只与内存有关。

Java有垃圾回收器负责回收无用对象占据的内存资源。
但也有特殊情况：假如你的对象（并非使用new）获得了一块特殊的内存区域，由于垃圾回收器  
只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存。

为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。
**工作原理**
一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次  
垃圾回收动作发生时，才会真正回收对象占用的内存。


 finalize()用来回收，通过某种创建对象方式以外的方式为对象分配的存储空间，不可直接调用finalize()。