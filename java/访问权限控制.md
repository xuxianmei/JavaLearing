访问控制（或隐藏具体实现）与“最初始的实现并不恰当”有关。

在与类使用者合作时，类使用者希望代的代码在某些方面保持不变，由此产生了在面向对象设计中  
需要考虑的一个基本问题：如何把变动的事物和保持不变的事物区分开来。

这对类库而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现  
了新版本，他们并不需要改写代码。从另一个方面来说，类库的开发者必须有权限进行修改和改进，  
并确保客户代码不会因为这些改动而受到影响。

# 包：库单元

包内包含有一组类，它们在单一的名字空间下被组织到了一起。

## 代码组织

* 编译单元
当编写一个Java源代码文件时，此文件通常被称为编译单元。
每个编译单元都必须有一个后缀名 .java，而在编译单元内则可以有一个public类，  
该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。
每个编译单元只能有一个public类。如果在该编译单元之中还有额外的类的话，那么在包之外  
是无法看见这些类的，因为它们不是public类。  

* 编译生成
当编译一个.Java文件时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与.java  
文件中的每个类的名称相同，只是多了一个后缀名.class。

* JAR
通过使用java的jar文档生成器，将一组.class文件打包并压缩成的一个jar文件。

* 类库
类库实际上是一组类文件，这些类文件，同属于同一个包。




## 包的创建与引入
package和import关键允许你做的，是将单一全局名字空间分隔开，使得无论多少人使用，  
都不会与其它类出现名称冲突。  
### 创建package

将类规划到包中，通过使用关键字package，使用时它必须是文件中除注释以外的第一句程序代码。  

	package com.tlxxm.learing;

这表示你在声明该编译单元是名为com.tlxxm.learing的类库的一部分。
如何想要使用该名称的人，都必须使用以下方式：
* 指定全名（如：com.tlxxm.learing.MyClass）
* 使用import

### 创建独一无二的包名

既然一个包从未真正将被打包的东西包装成单一的文件，并且一个包可以由许多.clss文件构成，  
这就容易产生混乱。
为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下。
这是Java解决混乱的一各方式，还可以使用另外一种方式jar来解决这个问题。

根据package拆解得到文件目录，Java程序运行需要加载.class文件时，就能通过这个目录去查找。

Java解释器运行过程如下：
1. 首先，找出环境变量CLASSPATH
2. 从根目录开始，解释器获取包的名称，并将每个句点替换成斜杠  
3. 以CLASSPATH根中产生一个路径名称，解释器就在这些目录中查找 与你所要创建的类名称相关的  
.class文件
注：解释器还会去查找某些涉及Java解释器所在位置的标准目录。

相同目录下所有不具有明确package声明的文件，都被视作是该目录下默认包的一部分。


### 包的引入

import packagename[.*|.ClassName]


注：无论何时创建包，都已经在给定包的名称的时候隐含地指定了目录结构。


# Java访问权限修饰词

public、protected、private这几个访问权限修饰词在使用时，是置于类中每个成员定义之前的。
如果不提供任何访问权限修饰，则意味它是包访问权限。无论如何，所有事物都具有某种形式的访问权限  
控制。

## 包访问权限 

不使用任何访问权限修饰词，这意味着当前包中的所有其他类对那个成员都有访问权限。

## public
针对外部完全开放
## private
不可用来修饰类，只可修饰类的成员，只有包含该成员的类之外，其他类都无法访问。
## protected
不可用来修饰类，只可修饰类的成员，子类可访问

注：类只能有两种选择：包访问权限和public。
# 接口与实现

访问权限的控制常被称为是：具体实现的隐藏。
把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是**_封装_**。
其结果是一个同时带有特征和行为的数据类型。 

访问权限控制将权限的边界划在数据类型的内部的两个重要原因：
* 设定类库使用者可以使用和不可以使用的界限
* 将接口和具体实现进行分离
