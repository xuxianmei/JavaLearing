# 线程基础



## 进程

进程是操作系统资源管理的最小单位，进程是一个动态的实体，它是程序的一次执行过程。
要想运行一个应用程序的实例，就必须创建一个进程，进程是这个实例要使用的资源的集合。
每个进程都被赋予了一个虚拟地址空间，确保进程中使用的代码和数据无法由另一个进程访问。

## 线程

线程的职责是对CPU进行虚拟化，是CPU调度和分派的基本单位最小单元。
每个进程都有该进程专用的线程（功能相当于一个CPU)。
线程自己基本上不拥有系统资源。
在运行时，只是暂用一些计数器、寄存器和栈 。

**现在的CLR线程完全等价于Windows线程。**

### 线程开销

线程有空间和时间上的开销

每个线程都有以下要素

* **线程内核对象**
OS会为每个线程都分配并初始化这种数据结构。
这种数据结构包含：
	* 一组对线程进行描述的属性
	* 线程上下文(thread context)
上下文是一个内存块，其中包含了CPU的寄存器集合。
* **线程环境块（thread environment block,TEB)**
TEB是在用户模式中分配和初始化的内存块。
TEB包含数据：
	* 异常处理链首
线程进入的每个try块都在链首插入一个节点。线程退出try块时，会从链中删除该节点
	* 线程的线程本地存储数据
	* 由GDI和OpenGL图形使用的一些数据结构
* **用户模式栈（user-mode stack)**
	* 存储传给方法的局部变量和实参
	* 包含当前方法的返回地址
* **内核模式栈（kernel-mode stack)**
应用程序代码向操作系统中的内核模式函数传递实参时，使用此栈。
* **DLL线程连接(attach)和线程分离(detach)通知**
任何时候在进程中创建一个线程，都会调用那个进程中加载的所有DLL的DLLMain方法，并向该方法传递一个DLL_THREAD_ATTACH标识。类似的，任何时候一个线程终止，都会调用进程中的所有DLL的DLLMain方法，并向该方法传递一个DLL_THREAD_DETACH标识。有的DLL需要利用这些通知，为进程中创建和销毁的每个线程执行一些特殊的初始化或资源清理操作。

虽然创建线程比创建进程更廉价（时间和资源），但和其他系统资源相比仍然十分昂贵，所以
还是能省则省。


### 线程上下文切换

单个CPU某个时间点，只能做一件事情。
所以所有线程（逻辑CPU）之间共享物理CPU。

CPU采用时间片轮转来为所有线程分配执行的**时间片**。
一个线程时间片到期，Widnows就上下文切换到另一个线程。
上下文切换过程：
1. 将CPU寄存器中的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。
2. 从现有线程集合中选出一个线程供调度。
如果该线程由另一个进程拥有，在开始执行线程时，还必须切换CPU**看见**的虚拟地址空间。
3. 将所选上下文结构中的值加载到CPU的寄存器中

完成上面3个步骤，CPU执行所选的线程，直到它的时间片到期。重复上面的操作。

#### 上下文切换的开销
上下文切换是净开销，也就是说，上下文切换所产生的开销不会换来任何内在和性能上的收益。

当切换到的线程，执行的代码和数据与上一个线程完全不一样时，就不能使得CPU的高速缓存，
需要访问 RAM来填充高速缓存，这个时候性能影响特别大，因为RAM速度比高速缓存慢得多。


**注：在设计自己的代码时，上下文切换能避免就要尽量避免。**

#### 线程的数量对GC的影响

在执行GC时，CLR必须挂起（暂停）所有线程，遍历它们的栈来查找根以便对堆中的对象进行标记，
再次遍历它们的栈，再恢复所有线程。

所以减少线程的数据也会显著提升垃圾回收器的性能。

**注：不能光关注性能和速度，当代操作系统更注重于可靠性和响应能力（吞吐量）**

### CLR线程和Windows线程
CLR现在用的是Windows的线程处理能力。
现在CLR线程完全等价Windows线程。
但Microsoft CLR团队保留了将来把它从Windows线程中分离的权限。
以后，CLR可能引入它自己的逻辑线程概念，使一个CLR逻辑线程并非一定映射到一个物理Windows线程。
据说，逻辑线程将使用比物理线程少的多的资源，所以能在极少量的物理线程上运行大量的逻辑线程。

### 使用专用线程执行异步的计算限制操作

如果执行的代码要求线程处于一种特定状态，而这种状态对于线程池来说是非同寻常的，
就可以考虑创建专用线程。

例如满足以下任何条件，就可显式创建自己的线程
* 线程需要以非普通线程优先级运行
* 需要线程表现为一个前台线程
* 计算限制的任务需要长时间运行
* 要启动线程，并可能调用Thread的Abort方法来提前终止它

使用Thread类


### 使用线程的理由

主要是出于两方面的原因使用线程

* 可响应性

* 性能

### 线程调度和优先级


每个线程的内核对象都包含一个上下文(context)结构，，它反映了线程上一次执行完毕后CPU寄存器的状态。
在一个时间片之后，Windows检查现存的所有线程内核对象，在这些对象中，只有那些没有正在等待
什么的线程才适合调度。

Windows之所以被抢占式多线程系统，是因为线程可在任何时间停止（被抢占）并调度另一个线程。

每个线程都分配了0-31（低-高）的优先级。
调度线程时，会从高到下检索，同优先级的轮流调度。
只要高优先级的线程准备好状态，可以被调度执行，永远轮不到下一级的线程。

注：系统启动时会创建一个特殊的零页线程，该线程的优先级是0，且只有这一个0级线程，
在其它线程都空闲时，该线程将系统RAM的所有空闲页清零。

### 前台线程和后台线程

线程分为两类：前台线程和后台线程。
一个进程的所有前台线程运行停止时，CLR强制终止该进程的所有运行中的后台线程。

所以，应该用前台线程执行确实想要完成的任务，比如将数据从内存缓冲区flush到磁盘中。
非关键性任务则使用后台线程，比如为记录建立索引，这是由于这些工作能在应用程序重启时继续，
而且如果用户想终止应用程序，就没有必要强迫应用程序保持活动。

应用程序的主线程以及通过构造一个Thread对象来显式创建的任何线程都默认为前台线程。
线程池线程默认为后台线程。
在线程的生存期内，可以进行前后台切换。



